// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.2

package orderitem

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"reflect"
	"slices"
	"strings"
	"time"

	"github.com/ettle/strcase"
	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/mysql"
	_ "github.com/golang-migrate/migrate/v4/source/file"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/redis"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	orderItemsFieldNames          = builder.RawFieldNames(&OrderItems{})
	orderItemsRows                = strings.Join(orderItemsFieldNames, ",")
	orderItemsRowsExpectAutoSet   = strings.Join(stringx.Remove(orderItemsFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	orderItemsRowsWithPlaceHolder = strings.Join(stringx.Remove(orderItemsFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheOrderItemsIdPrefix    = "cache:orderItems:id:"
	cacheOrderItemsCountPrefix = "cache:orderItems:list:count:"
	cacheOrderItemsListPrefix  = "cache:orderItems:list:"
)

type Option struct {
	session      sqlx.Session
	isSoftDelete bool
}

type OptionFunc func(*Option)

func WithSession(session sqlx.Session) OptionFunc {
	return func(o *Option) {
		o.session = session
	}
}

func WithIsSoftDelete(isSoftDelete bool) OptionFunc {
	return func(o *Option) {
		o.isSoftDelete = isSoftDelete
	}
}

type (
	orderItemsModel interface {
		Insert(ctx context.Context, data *OrderItems, options ...OptionFunc) (sql.Result, error)
		Delete(ctx context.Context, data *OrderItems, options ...OptionFunc) error
		FindOne(ctx context.Context, id int64, options ...OptionFunc) (*OrderItems, error)
		FindList(ctx context.Context, page *OrderItemsPage, filters []*OrderItemsFilter, orders []*OrderItemsOrder, options ...OptionFunc) ([]*OrderItems, int32, error)
		Update(ctx context.Context, data *OrderItems, options ...OptionFunc) error
		UpdateWithFields(ctx context.Context, data *OrderItems, fields []string, options ...OptionFunc) error
	}

	CacheKeyGenerator func(data *OrderItems) []string

	defaultOrderItemsModel struct {
		sqlc.CachedConn
		table             string
		redisCache        *redis.Redis
		conn              sqlx.SqlConn
		isCluster         bool
		keyGenerators     []CacheKeyGenerator
		patternGenerators []CacheKeyGenerator
	}

	OrderItems struct {
		Id         int64     `db:"id"`
		OrderId    int64     `db:"order_id"`   // 訂單ID
		ProductId  string    `db:"product_id"` // 產品ID
		Quantity   int64     `db:"quantity"`   // 數量
		Price      float64   `db:"price"`      // 單價
		CreateTime time.Time `db:"create_time"`
		UpdateTime time.Time `db:"update_time"`
	}

	OrderItemsPage struct {
		Limit int64
		Page  int64
	}

	OrderItemsFilter struct {
		Field    string
		Operator string
		Value    interface{}
	}

	OrderItemsOrder struct {
		Field string
		Dir   string
	}
)

func newOrderItemsModel(conn sqlx.SqlConn, migratePath string, c cache.CacheConf, opts ...cache.Option) *defaultOrderItemsModel {
	redisCache, err := redis.NewRedis(c[0].RedisConf)
	if err != nil {
		panic(err)
	}

	db, err := conn.RawDB()
	if err != nil {
		panic(err)
	}

	err = migrateDB(migratePath, db)
	if err != nil {
		panic(err)
	}

	model := &defaultOrderItemsModel{
		CachedConn: sqlc.NewNodeConn(conn, redisCache, opts...),
		table:      "`order_items`",
		redisCache: redisCache,
		conn:       conn,
		isCluster:  c[0].RedisConf.Type == "cluster",
	}

	model.RegisterCachePatternGenerator(func(data *OrderItems) []string {
		return []string{
			fmt.Sprintf("%s*", cacheOrderItemsListPrefix),
		}
	})

	return model
}

func (m *defaultOrderItemsModel) RegisterCacheKeyGenerator(generator CacheKeyGenerator) {
	m.keyGenerators = append(m.keyGenerators, generator)
}

// ClearCacheKeyGenerators 清空所有注册的生成器
func (m *defaultOrderItemsModel) ClearCacheKeyGenerators() {
	m.keyGenerators = []CacheKeyGenerator{}
}

func (m *defaultOrderItemsModel) RegisterCachePatternGenerator(generator CacheKeyGenerator) {
	m.patternGenerators = append(m.patternGenerators, generator)
}

// ClearCachePatternGenerators 清空所有注册的生成器
func (m *defaultOrderItemsModel) ClearCachePatternGenerators() {
	m.patternGenerators = []CacheKeyGenerator{}
}

func (m *defaultOrderItemsModel) FindOne(ctx context.Context, id int64, options ...OptionFunc) (*OrderItems, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	orderItemsIdKey := fmt.Sprintf("%s%v", cacheOrderItemsIdPrefix, id)
	var resp OrderItems
	err := m.QueryRowCtx(ctx, &resp, orderItemsIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("select %s from %s where `id` = ? and `deleted_at` is null limit 1", orderItemsRows, m.table)
		} else {
			query = fmt.Sprintf("select %s from %s where `id` = ? limit 1", orderItemsRows, m.table)
		}
		if option.session != nil {
			return option.session.QueryRowCtx(ctx, v, query, id)
		}
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultOrderItemsModel) FindList(ctx context.Context, page *OrderItemsPage, filters []*OrderItemsFilter, orders []*OrderItemsOrder, options ...OptionFunc) ([]*OrderItems, int32, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	orderItemsIdKey := fmt.Sprintf("%s%v%v%v", cacheOrderItemsListPrefix, page, filters, orders)
	orderItemsCountKey := fmt.Sprintf("%s%v%v%v", cacheOrderItemsCountPrefix, page, filters, orders)
	var resp []*OrderItems
	var totalCount int32
	err := m.QueryRowCtx(ctx, &resp, orderItemsIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		queryStr, args := m.getFindsAllQueryString(page, filters, orders, option.isSoftDelete)
		finalQuery := fmt.Sprintf(queryStr, orderItemsRows, m.table)
		if option.session != nil {
			return option.session.QueryRowsCtx(ctx, v, finalQuery, args...)
		}
		return conn.QueryRowsCtx(ctx, v, finalQuery, args...)
	})
	if err != nil {
		return nil, 0, err
	}

	err = m.QueryRowCtx(ctx, &totalCount, orderItemsCountKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		queryStr, args := m.getFindsAllCountQueryString(filters, option.isSoftDelete)
		countQuery := fmt.Sprintf(queryStr, m.table)
		if option.session != nil {
			return option.session.QueryRowCtx(ctx, v, countQuery, args...)
		}
		return conn.QueryRowCtx(ctx, v, countQuery, args...)
	})
	switch err {
	case nil:
		return resp, totalCount, nil
	case sqlc.ErrNotFound:
		return nil, 0, ErrNotFound
	default:
		return nil, 0, err
	}

}

func (m *defaultOrderItemsModel) Insert(ctx context.Context, data *OrderItems, options ...OptionFunc) (sql.Result, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}

	orderItemsIdKey := fmt.Sprintf("%s%v", cacheOrderItemsIdPrefix, data.Id)
	keys := []string{
		orderItemsIdKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(data)...)
	}
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {

		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, data)
		if err != nil {
			return nil, err
		}

		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?)", m.table, orderItemsRowsExpectAutoSet)
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, data.OrderId, data.ProductId, data.Quantity, data.Price)
		}
		return conn.ExecCtx(ctx, query, data.OrderId, data.ProductId, data.Quantity, data.Price)
	}, keys...)

	return ret, err
}
func (m *defaultOrderItemsModel) Update(ctx context.Context, data *OrderItems, options ...OptionFunc) error {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	orderItemsIdKey := fmt.Sprintf("%s%v", cacheOrderItemsIdPrefix, data.Id)
	keys := []string{
		orderItemsIdKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(data)...)
	}
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, data)
		if err != nil {
			return nil, err
		}

		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("update %s set %s where `id` = ? and `deleted_at` is null", m.table, orderItemsRowsWithPlaceHolder)
		} else {
			query = fmt.Sprintf("update %s set %s where `id` = ?", m.table, orderItemsRowsWithPlaceHolder)
		}
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, data.OrderId, data.ProductId, data.Quantity, data.Price, data.Id)
		}
		return conn.ExecCtx(ctx, query, data.OrderId, data.ProductId, data.Quantity, data.Price, data.Id)
	}, keys...)
	return err
}

func (m *defaultOrderItemsModel) UpdateWithFields(ctx context.Context, data *OrderItems, fields []string, options ...OptionFunc) error {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	orderItemsIdKey := fmt.Sprintf("%s%v", cacheOrderItemsIdPrefix, data.Id)
	keys := []string{
		orderItemsIdKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(data)...)
	}
	orderItemsMap, err := m.structToMap(data)
	if err != nil {
		return err
	}
	setClause := make([]string, 0, len(fields))
	args := make([]interface{}, 0, len(fields)+1)

	rows := strings.Replace(orderItemsRows, "`", "", -1)
	allowFields := strings.Split(rows, ",")
	for _, field := range fields {
		if !slices.Contains(allowFields, field) {
			return fmt.Errorf("非法的字段名稱: %s", field)
		}
		setClause = append(setClause, fmt.Sprintf("`%s` = ?", field))
		args = append(args, orderItemsMap[strcase.ToPascal(field)])
	}

	if len(setClause) == 0 {
		return fmt.Errorf("没有指定要更新的字段")
	}

	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, data)
		if err != nil {
			return nil, err
		}
		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("update %s set %s where `id` = ? and `deleted_at` is null", m.table, strings.Join(setClause, ", "))
		} else {
			query = fmt.Sprintf("update %s set %s where `id` = ?", m.table, strings.Join(setClause, ", "))
		}
		args = append(args, data.Id)
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, args...)
		}
		return conn.ExecCtx(ctx, query, args...)
	}, keys...)
	return err
}

func (m *defaultOrderItemsModel) Delete(ctx context.Context, data *OrderItems, options ...OptionFunc) error {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}

	orderItemsIdKey := fmt.Sprintf("%s%v", cacheOrderItemsIdPrefix, data.Id)
	keys := []string{
		orderItemsIdKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(data)...)
	}
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, data)
		if err != nil {
			return nil, err
		}
		var query string
		args := []interface{}{}
		if option.isSoftDelete {
			query = fmt.Sprintf("update %s set `deleted_at` = FROM_UNIXTIME(?) where `id` = ?", m.table)
			args = append(args, time.Now().Unix())
		} else {
			query = fmt.Sprintf("delete from %s where `id` = ?", m.table)
		}
		args = append(args, data.Id)
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, args...)
		}
		return conn.ExecCtx(ctx, query, args...)
	}, keys...)
	return err
}

func (m *defaultOrderItemsModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheOrderItemsIdPrefix, primary)
}

func (m *defaultOrderItemsModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", orderItemsRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultOrderItemsModel) tableName() string {
	return m.table
}

func (m *defaultOrderItemsModel) GetConn() sqlx.SqlConn {
	return m.conn
}

func (m *defaultOrderItemsModel) deleteRedisPatternCache(ctx context.Context, data *OrderItems) error {
	if m.redisCache == nil {
		return nil
	}

	if len(m.patternGenerators) == 0 {
		return nil
	}

	var cursor uint64
	for _, generator := range m.patternGenerators {
		patterns := generator(data)
		for _, pattern := range patterns {
			for {
				// 使用 SCAN 获取匹配的键
				keys, nextCursor, err := m.redisCache.ScanCtx(ctx, cursor, pattern, 0)
				if err != nil {
					return err
				}

				// 如果有键需要删除，使用 PipelinedCtx 批量删除
				if len(keys) > 0 {
					err = m.redisCache.PipelinedCtx(ctx, func(pipe redis.Pipeliner) error {
						if m.isCluster {
							for _, key := range keys {
								pipe.Del(ctx, key)
							}
						} else {
							pipe.Del(ctx, keys...)
						}
						return nil
					})
					if err != nil {
						return err
					}
				}

				cursor = nextCursor
				if cursor == 0 {
					break
				}
			}
		}
	}
	return nil
}

func (m *defaultOrderItemsModel) structToMap(data *OrderItems) (map[string]interface{}, error) {
	orderItemsType := reflect.TypeOf(*data)
	orderItemsValue := reflect.ValueOf(*data)

	orderItemsMap := make(map[string]interface{})

	for i := 0; i < orderItemsType.NumField(); i++ {
		field := orderItemsType.Field(i)
		fieldName := field.Name
		fieldValue := orderItemsValue.Field(i)

		if fieldValue.CanInterface() {
			orderItemsMap[fieldName] = fieldValue.Interface()
		}
	}

	return orderItemsMap, nil
}

func (m *defaultOrderItemsModel) addFilter(query string, filters []*OrderItemsFilter, softDelete bool) (string, []interface{}) {
	args := make([]interface{}, 0)
	if len(filters) == 0 {
		return query, args
	}
	if !softDelete {
		query += " WHERE "
	} else {
		query += " AND "
	}
	for idx, filter := range filters {
		if idx > 0 {
			query += " AND "
		}
		operator := strings.ToUpper(filter.Operator)
		switch operator {
		case "IN", "NOT IN":
			val := reflect.ValueOf(filter.Value)
			if val.Kind() != reflect.Slice || val.Len() == 0 {
				query += "1=0"
				continue
			}
			placeholders := make([]string, val.Len())
			for i := 0; i < val.Len(); i++ {
				placeholders[i] = "?"
				args = append(args, val.Index(i).Interface())
			}
			query += fmt.Sprintf("`%s` %s (%s)", filter.Field, operator, strings.Join(placeholders, ","))

		case "BETWEEN":
			val := reflect.ValueOf(filter.Value)
			if val.Kind() != reflect.Slice || val.Len() != 2 {
				query += "1=0"
				continue
			}
			query += fmt.Sprintf("`%s` BETWEEN ? AND ?", filter.Field)
			args = append(args, val.Index(0).Interface(), val.Index(1).Interface())

		case "IS NULL", "IS NOT NULL":
			query += fmt.Sprintf("`%s` %s", filter.Field, operator)

		default:
			query += fmt.Sprintf("`%s` %s ?", filter.Field, operator)
			args = append(args, filter.Value)
		}
	}
	return query, args
}

func (m *defaultOrderItemsModel) addOrder(query string, orders []*OrderItemsOrder) (string, []interface{}) {
	args := make([]interface{}, 0)
	if len(orders) == 0 {
		return query + " ORDER BY `id` DESC", args // 默认排序
	}
	query += " ORDER BY "
	for i, order := range orders {
		if i > 0 {
			query += ", "
		}
		query += fmt.Sprintf("`%s` %s", order.Field, order.Dir)
	}
	return query, args
}

func (m *defaultOrderItemsModel) getFindsAllQueryString(page *OrderItemsPage, filters []*OrderItemsFilter, orders []*OrderItemsOrder, softDelete bool) (string, []interface{}) {
	if page == nil {
		page = &OrderItemsPage{
			Limit: 0,
			Page:  0,
		}
	}
	offset := (page.Page - 1) * page.Limit
	if offset < 0 {
		offset = 0
	}
	listQuery := "SELECT %s FROM %s"
	if softDelete {
		listQuery += " WHERE `deleted_at` IS NULL"
	}
	listQuery, args := m.addFilter(listQuery, filters, softDelete)
	listQuery, orderArgs := m.addOrder(listQuery, orders)
	args = append(args, orderArgs...)

	if page.Limit > 0 {
		listQuery += " LIMIT ? OFFSET ?"
		args = append(args, page.Limit, offset)
	}
	return listQuery, args
}

func (m *defaultOrderItemsModel) getFindsAllCountQueryString(filters []*OrderItemsFilter, softDelete bool) (string, []interface{}) {
	countQuery := "SELECT COUNT(*) FROM %s "
	if softDelete {
		countQuery += "WHERE `deleted_at` IS NULL "
	}
	countQuery, args := m.addFilter(countQuery, filters, softDelete)
	return countQuery, args
}

func migrateDB(path string, db *sql.DB) error {
	driver, err := mysql.WithInstance(db, &mysql.Config{})
	if err != nil {
		log.Fatalf("Failed to get raw database connection: %v", err)
	}
	m, err := migrate.NewWithDatabaseInstance(
		"file://"+path,
		"mysql",
		driver,
	)
	if err != nil {
		log.Fatalf("Failed to create migrate instance: %v", err)
	}
	// m.Down()
	err = m.Up()
	if err != nil && err != migrate.ErrNoChange {
		log.Fatalf("Failed to migrate database: %v", err)
	}

	return nil
}
