// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.2

package order

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"reflect"
	"slices"
	"strings"
	"time"

	"github.com/ettle/strcase"
	"github.com/golang-migrate/migrate/v4"
	"github.com/golang-migrate/migrate/v4/database/mysql"
	_ "github.com/golang-migrate/migrate/v4/source/file"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/redis"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	ordersFieldNames          = builder.RawFieldNames(&Orders{})
	ordersRows                = strings.Join(ordersFieldNames, ",")
	ordersRowsExpectAutoSet   = strings.Join(stringx.Remove(ordersFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	ordersRowsWithPlaceHolder = strings.Join(stringx.Remove(ordersFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheOrdersIdPrefix      = "cache:orders:id:"
	cacheOrdersOrderSnPrefix = "cache:orders:orderSn:"
	cacheOrdersCountPrefix   = "cache:orders:list:count:"
	cacheOrdersListPrefix    = "cache:orders:list:"
)

type Option struct {
	session      sqlx.Session
	isSoftDelete bool
}

type OptionFunc func(*Option)

func WithSession(session sqlx.Session) OptionFunc {
	return func(o *Option) {
		o.session = session
	}
}

func WithIsSoftDelete(isSoftDelete bool) OptionFunc {
	return func(o *Option) {
		o.isSoftDelete = isSoftDelete
	}
}

type (
	ordersModel interface {
		Insert(ctx context.Context, data *Orders, options ...OptionFunc) (sql.Result, error)
		Delete(ctx context.Context, data *Orders, options ...OptionFunc) error
		FindOne(ctx context.Context, id int64, options ...OptionFunc) (*Orders, error)
		FindList(ctx context.Context, page *OrdersPage, filters []*OrdersFilter, orders []*OrdersOrder, options ...OptionFunc) ([]*Orders, int32, error)
		FindOneByOrderSn(ctx context.Context, orderSn string, options ...OptionFunc) (*Orders, error)
		Update(ctx context.Context, data *Orders, options ...OptionFunc) error
		UpdateWithFields(ctx context.Context, data *Orders, fields []string, options ...OptionFunc) error
	}

	CacheKeyGenerator func(data *Orders) []string

	defaultOrdersModel struct {
		sqlc.CachedConn
		table             string
		redisCache        *redis.Redis
		conn              sqlx.SqlConn
		isCluster         bool
		keyGenerators     []CacheKeyGenerator
		patternGenerators []CacheKeyGenerator
	}

	Orders struct {
		Id          int64     `db:"id"`           // 訂單ID
		OrderSn     string    `db:"order_sn"`     // 訂單編號
		UserId      int64     `db:"user_id"`      // 用戶ID
		TotalAmount float64   `db:"total_amount"` // 訂單總金額
		Status      int64     `db:"status"`       // 訂單狀態 0:待支付 1:已支付 2:已發貨 3:已完成 4:已取消
		CreateTime  time.Time `db:"create_time"`
		UpdateTime  time.Time `db:"update_time"`
	}

	OrdersPage struct {
		Limit int64
		Page  int64
	}

	OrdersFilter struct {
		Field    string
		Operator string
		Value    interface{}
	}

	OrdersOrder struct {
		Field string
		Dir   string
	}
)

func newOrdersModel(conn sqlx.SqlConn, migratePath string, c cache.CacheConf, opts ...cache.Option) *defaultOrdersModel {
	redisCache, err := redis.NewRedis(c[0].RedisConf)
	if err != nil {
		panic(err)
	}

	db, err := conn.RawDB()
	if err != nil {
		panic(err)
	}

	err = migrateDB(migratePath, db)
	if err != nil {
		panic(err)
	}

	model := &defaultOrdersModel{
		CachedConn: sqlc.NewNodeConn(conn, redisCache, opts...),
		table:      "`orders`",
		redisCache: redisCache,
		conn:       conn,
		isCluster:  c[0].RedisConf.Type == "cluster",
	}

	model.RegisterCachePatternGenerator(func(data *Orders) []string {
		return []string{
			fmt.Sprintf("%s*", cacheOrdersListPrefix),
		}
	})

	return model
}

func (m *defaultOrdersModel) RegisterCacheKeyGenerator(generator CacheKeyGenerator) {
	m.keyGenerators = append(m.keyGenerators, generator)
}

// ClearCacheKeyGenerators 清空所有注册的生成器
func (m *defaultOrdersModel) ClearCacheKeyGenerators() {
	m.keyGenerators = []CacheKeyGenerator{}
}

func (m *defaultOrdersModel) RegisterCachePatternGenerator(generator CacheKeyGenerator) {
	m.patternGenerators = append(m.patternGenerators, generator)
}

// ClearCachePatternGenerators 清空所有注册的生成器
func (m *defaultOrdersModel) ClearCachePatternGenerators() {
	m.patternGenerators = []CacheKeyGenerator{}
}

func (m *defaultOrdersModel) FindOne(ctx context.Context, id int64, options ...OptionFunc) (*Orders, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	ordersIdKey := fmt.Sprintf("%s%v", cacheOrdersIdPrefix, id)
	var resp Orders
	err := m.QueryRowCtx(ctx, &resp, ordersIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("select %s from %s where `id` = ? and `deleted_at` is null limit 1", ordersRows, m.table)
		} else {
			query = fmt.Sprintf("select %s from %s where `id` = ? limit 1", ordersRows, m.table)
		}
		if option.session != nil {
			return option.session.QueryRowCtx(ctx, v, query, id)
		}
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultOrdersModel) FindList(ctx context.Context, page *OrdersPage, filters []*OrdersFilter, orders []*OrdersOrder, options ...OptionFunc) ([]*Orders, int32, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	ordersIdKey := fmt.Sprintf("%s%v%v%v", cacheOrdersListPrefix, page, filters, orders)
	ordersCountKey := fmt.Sprintf("%s%v%v%v", cacheOrdersCountPrefix, page, filters, orders)
	var resp []*Orders
	var totalCount int32
	err := m.QueryRowCtx(ctx, &resp, ordersIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		queryStr, args := m.getFindsAllQueryString(page, filters, orders, option.isSoftDelete)
		finalQuery := fmt.Sprintf(queryStr, ordersRows, m.table)
		if option.session != nil {
			return option.session.QueryRowsCtx(ctx, v, finalQuery, args...)
		}
		return conn.QueryRowsCtx(ctx, v, finalQuery, args...)
	})
	if err != nil {
		return nil, 0, err
	}

	err = m.QueryRowCtx(ctx, &totalCount, ordersCountKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		queryStr, args := m.getFindsAllCountQueryString(filters, option.isSoftDelete)
		countQuery := fmt.Sprintf(queryStr, m.table)
		if option.session != nil {
			return option.session.QueryRowCtx(ctx, v, countQuery, args...)
		}
		return conn.QueryRowCtx(ctx, v, countQuery, args...)
	})
	switch err {
	case nil:
		return resp, totalCount, nil
	case sqlc.ErrNotFound:
		return nil, 0, ErrNotFound
	default:
		return nil, 0, err
	}

}
func (m *defaultOrdersModel) FindOneByOrderSn(ctx context.Context, orderSn string, options ...OptionFunc) (*Orders, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}

	ordersOrderSnKey := fmt.Sprintf("%s%v", cacheOrdersOrderSnPrefix, orderSn)
	var resp Orders
	err := m.QueryRowIndexCtx(ctx, &resp, ordersOrderSnKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("select %s from %s where `order_sn` = ? and deleted_at is null limit 1", ordersRows, m.table)
		} else {
			query = fmt.Sprintf("select %s from %s where `order_sn` = ? limit 1", ordersRows, m.table)
		}
		if option.session != nil {
			err := option.session.QueryRowCtx(ctx, &resp, query, orderSn)
			if err != nil {
				return nil, err
			}
			return resp.Id, nil
		}
		err := conn.QueryRowCtx(ctx, &resp, query, orderSn)
		if err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultOrdersModel) Insert(ctx context.Context, data *Orders, options ...OptionFunc) (sql.Result, error) {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}

	ordersIdKey := fmt.Sprintf("%s%v", cacheOrdersIdPrefix, data.Id)
	ordersOrderSnKey := fmt.Sprintf("%s%v", cacheOrdersOrderSnPrefix, data.OrderSn)
	keys := []string{
		ordersIdKey, ordersOrderSnKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(data)...)
	}
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {

		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, data)
		if err != nil {
			return nil, err
		}

		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?)", m.table, ordersRowsExpectAutoSet)
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, data.OrderSn, data.UserId, data.TotalAmount, data.Status)
		}
		return conn.ExecCtx(ctx, query, data.OrderSn, data.UserId, data.TotalAmount, data.Status)
	}, keys...)

	return ret, err
}
func (m *defaultOrdersModel) Update(ctx context.Context, newData *Orders, options ...OptionFunc) error {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	data, err := m.FindOne(ctx, newData.Id, options...)
	if err != nil {
		return err
	}

	ordersIdKey := fmt.Sprintf("%s%v", cacheOrdersIdPrefix, data.Id)
	ordersOrderSnKey := fmt.Sprintf("%s%v", cacheOrdersOrderSnPrefix, data.OrderSn)
	keys := []string{
		ordersIdKey, ordersOrderSnKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(newData)...)
	}
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, newData)
		if err != nil {
			return nil, err
		}

		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("update %s set %s where `id` = ? and `deleted_at` is null", m.table, ordersRowsWithPlaceHolder)
		} else {
			query = fmt.Sprintf("update %s set %s where `id` = ?", m.table, ordersRowsWithPlaceHolder)
		}
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, newData.OrderSn, newData.UserId, newData.TotalAmount, newData.Status, newData.Id)
		}
		return conn.ExecCtx(ctx, query, newData.OrderSn, newData.UserId, newData.TotalAmount, newData.Status, newData.Id)
	}, keys...)
	return err
}

func (m *defaultOrdersModel) UpdateWithFields(ctx context.Context, newData *Orders, fields []string, options ...OptionFunc) error {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}
	data, err := m.FindOne(ctx, newData.Id, options...)
	if err != nil {
		return err
	}

	ordersIdKey := fmt.Sprintf("%s%v", cacheOrdersIdPrefix, data.Id)
	ordersOrderSnKey := fmt.Sprintf("%s%v", cacheOrdersOrderSnPrefix, data.OrderSn)
	keys := []string{
		ordersIdKey, ordersOrderSnKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(newData)...)
	}
	ordersMap, err := m.structToMap(newData)
	if err != nil {
		return err
	}
	setClause := make([]string, 0, len(fields))
	args := make([]interface{}, 0, len(fields)+1)

	rows := strings.Replace(ordersRows, "`", "", -1)
	allowFields := strings.Split(rows, ",")
	for _, field := range fields {
		if !slices.Contains(allowFields, field) {
			return fmt.Errorf("非法的字段名稱: %s", field)
		}
		setClause = append(setClause, fmt.Sprintf("`%s` = ?", field))
		args = append(args, ordersMap[strcase.ToPascal(field)])
	}

	if len(setClause) == 0 {
		return fmt.Errorf("没有指定要更新的字段")
	}

	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, newData)
		if err != nil {
			return nil, err
		}
		var query string
		if option.isSoftDelete {
			query = fmt.Sprintf("update %s set %s where `id` = ? and `deleted_at` is null", m.table, strings.Join(setClause, ", "))
		} else {
			query = fmt.Sprintf("update %s set %s where `id` = ?", m.table, strings.Join(setClause, ", "))
		}
		args = append(args, data.Id)
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, args...)
		}
		return conn.ExecCtx(ctx, query, args...)
	}, keys...)
	return err
}

func (m *defaultOrdersModel) Delete(ctx context.Context, data *Orders, options ...OptionFunc) error {
	option := &Option{}
	for _, opt := range options {
		opt(option)
	}

	ordersIdKey := fmt.Sprintf("%s%v", cacheOrdersIdPrefix, data.Id)
	ordersOrderSnKey := fmt.Sprintf("%s%v", cacheOrdersOrderSnPrefix, data.OrderSn)
	keys := []string{
		ordersIdKey, ordersOrderSnKey,
	}
	for _, generator := range m.keyGenerators {
		keys = append(keys, generator(data)...)
	}
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		// 更新 Redis 缓存
		err = m.deleteRedisPatternCache(ctx, data)
		if err != nil {
			return nil, err
		}
		var query string
		args := []interface{}{}
		if option.isSoftDelete {
			query = fmt.Sprintf("update %s set `deleted_at` = FROM_UNIXTIME(?) where `id` = ?", m.table)
			args = append(args, time.Now().Unix())
		} else {
			query = fmt.Sprintf("delete from %s where `id` = ?", m.table)
		}
		args = append(args, data.Id)
		if option.session != nil {
			return option.session.ExecCtx(ctx, query, args...)
		}
		return conn.ExecCtx(ctx, query, args...)
	}, keys...)
	return err
}

func (m *defaultOrdersModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheOrdersIdPrefix, primary)
}

func (m *defaultOrdersModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", ordersRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultOrdersModel) tableName() string {
	return m.table
}

func (m *defaultOrdersModel) GetConn() sqlx.SqlConn {
	return m.conn
}

func (m *defaultOrdersModel) deleteRedisPatternCache(ctx context.Context, data *Orders) error {
	if m.redisCache == nil {
		return nil
	}

	if len(m.patternGenerators) == 0 {
		return nil
	}

	var cursor uint64
	for _, generator := range m.patternGenerators {
		patterns := generator(data)
		for _, pattern := range patterns {
			for {
				// 使用 SCAN 获取匹配的键
				keys, nextCursor, err := m.redisCache.ScanCtx(ctx, cursor, pattern, 0)
				if err != nil {
					return err
				}

				// 如果有键需要删除，使用 PipelinedCtx 批量删除
				if len(keys) > 0 {
					err = m.redisCache.PipelinedCtx(ctx, func(pipe redis.Pipeliner) error {
						if m.isCluster {
							for _, key := range keys {
								pipe.Del(ctx, key)
							}
						} else {
							pipe.Del(ctx, keys...)
						}
						return nil
					})
					if err != nil {
						return err
					}
				}

				cursor = nextCursor
				if cursor == 0 {
					break
				}
			}
		}
	}
	return nil
}

func (m *defaultOrdersModel) structToMap(data *Orders) (map[string]interface{}, error) {
	ordersType := reflect.TypeOf(*data)
	ordersValue := reflect.ValueOf(*data)

	ordersMap := make(map[string]interface{})

	for i := 0; i < ordersType.NumField(); i++ {
		field := ordersType.Field(i)
		fieldName := field.Name
		fieldValue := ordersValue.Field(i)

		if fieldValue.CanInterface() {
			ordersMap[fieldName] = fieldValue.Interface()
		}
	}

	return ordersMap, nil
}

func (m *defaultOrdersModel) addFilter(query string, filters []*OrdersFilter, softDelete bool) (string, []interface{}) {
	args := make([]interface{}, 0)
	if len(filters) == 0 {
		return query, args
	}
	if !softDelete {
		query += " WHERE "
	} else {
		query += " AND "
	}
	for idx, filter := range filters {
		if idx > 0 {
			query += " AND "
		}
		operator := strings.ToUpper(filter.Operator)
		switch operator {
		case "IN", "NOT IN":
			val := reflect.ValueOf(filter.Value)
			if val.Kind() != reflect.Slice || val.Len() == 0 {
				query += "1=0"
				continue
			}
			placeholders := make([]string, val.Len())
			for i := 0; i < val.Len(); i++ {
				placeholders[i] = "?"
				args = append(args, val.Index(i).Interface())
			}
			query += fmt.Sprintf("`%s` %s (%s)", filter.Field, operator, strings.Join(placeholders, ","))

		case "BETWEEN":
			val := reflect.ValueOf(filter.Value)
			if val.Kind() != reflect.Slice || val.Len() != 2 {
				query += "1=0"
				continue
			}
			query += fmt.Sprintf("`%s` BETWEEN ? AND ?", filter.Field)
			args = append(args, val.Index(0).Interface(), val.Index(1).Interface())

		case "IS NULL", "IS NOT NULL":
			query += fmt.Sprintf("`%s` %s", filter.Field, operator)

		default:
			query += fmt.Sprintf("`%s` %s ?", filter.Field, operator)
			args = append(args, filter.Value)
		}
	}
	return query, args
}

func (m *defaultOrdersModel) addOrder(query string, orders []*OrdersOrder) (string, []interface{}) {
	args := make([]interface{}, 0)
	if len(orders) == 0 {
		return query + " ORDER BY `id` DESC", args // 默认排序
	}
	query += " ORDER BY "
	for i, order := range orders {
		if i > 0 {
			query += ", "
		}
		query += fmt.Sprintf("`%s` %s", order.Field, order.Dir)
	}
	return query, args
}

func (m *defaultOrdersModel) getFindsAllQueryString(page *OrdersPage, filters []*OrdersFilter, orders []*OrdersOrder, softDelete bool) (string, []interface{}) {
	if page == nil {
		page = &OrdersPage{
			Limit: 0,
			Page:  0,
		}
	}
	offset := (page.Page - 1) * page.Limit
	if offset < 0 {
		offset = 0
	}
	listQuery := "SELECT %s FROM %s"
	if softDelete {
		listQuery += " WHERE `deleted_at` IS NULL"
	}
	listQuery, args := m.addFilter(listQuery, filters, softDelete)
	listQuery, orderArgs := m.addOrder(listQuery, orders)
	args = append(args, orderArgs...)

	if page.Limit > 0 {
		listQuery += " LIMIT ? OFFSET ?"
		args = append(args, page.Limit, offset)
	}
	return listQuery, args
}

func (m *defaultOrdersModel) getFindsAllCountQueryString(filters []*OrdersFilter, softDelete bool) (string, []interface{}) {
	countQuery := "SELECT COUNT(*) FROM %s "
	if softDelete {
		countQuery += "WHERE `deleted_at` IS NULL "
	}
	countQuery, args := m.addFilter(countQuery, filters, softDelete)
	return countQuery, args
}

func migrateDB(path string, db *sql.DB) error {
	driver, err := mysql.WithInstance(db, &mysql.Config{})
	if err != nil {
		log.Fatalf("Failed to get raw database connection: %v", err)
	}
	m, err := migrate.NewWithDatabaseInstance(
		"file://"+path,
		"mysql",
		driver,
	)
	if err != nil {
		log.Fatalf("Failed to create migrate instance: %v", err)
	}
	// m.Down()
	err = m.Up()
	if err != nil && err != migrate.ErrNoChange {
		log.Fatalf("Failed to migrate database: %v", err)
	}

	return nil
}
